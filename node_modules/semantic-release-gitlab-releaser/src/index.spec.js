'use strict';

/* eslint-disable no-unused-expressions */

const chai = require(`chai`);
const chaiAsPromised = require(`chai-as-promised`);
const mocha = require(`mocha`);
const nock = require(`nock`);
const proxyquire = require(`proxyquire`).noCallThru();
const sinon = require(`sinon`);
const sinonChai = require(`sinon-chai`);

chai.use(chaiAsPromised);
chai.use(sinonChai);
const expect = chai.expect;

const before = mocha.before;
const beforeEach = mocha.beforeEach;
const describe = mocha.describe;
const it = mocha.it;

describe(`semantic-release-gitlab-releaser`, function () {
  before(function () {
    nock.disableNetConnect();
  });

  beforeEach(function () {
    this.config = {
      options: {
        debug: false,
        scmToken: `TOKEN`,
      },
      pkg: {
        repository: `https://gitlab.com/hyper-expanse/semantic-release-gitlab-releaser.git`,
      },
    };

    this.conventionalGitlabReleaserMock = sinon.stub();

    this.getPkgRepoMock = sinon.stub();

    this.plugin = proxyquire(`./index`, {
      'conventional-gitlab-releaser': this.conventionalGitlabReleaserMock,
      'get-pkg-repo': this.getPkgRepoMock,
    });

    this.getPkgRepoMock.returns({
      domain: `gitlab.com`,
    });
  });

  it(`does not run in debug mode`, function () {
    this.config.options.debug = true;

    const promise = this.plugin(this.config);

    return expect(promise).to.be.fulfilled
      .and.to.eventually.equal(false);
  });

  it(`will reject if a 'pkg' object is not passed in the 'config' argument`, function () {
    delete this.config.pkg;

    const promise = this.plugin(this.config);

    return expect(promise).to.be.rejectedWith(Error, 'This plugin, ' +
      '`semantic-release-gitlab-releaser`, was not passed the contents of your package\'s ' +
      '`package.json` file. Please contact the user of this plugin and request that they pass ' +
      'the contents of `package.json` to the plugin.');
  });

  it(`will reject if no repository information in 'pkg' property of 'config'`, function () {
    this.getPkgRepoMock.throws(new Error(`No repository`));

    const promise = this.plugin(this.config);

    return expect(promise)
      .to.be.rejectedWith(Error, `No repository`);
  });

  it(`throws error if get-pkg-repo returns no repository domain`, function () {
    this.getPkgRepoMock.returns({});

    const promise = this.plugin(this.config);

    return expect(promise)
      .to.be.rejectedWith(Error, `Unable to parse the repository URL.`);
  });

  it(`will reject if no SCM token provided`, function () {
    delete this.config.options.scmToken;

    const promise = this.plugin(this.config);

    return expect(promise)
      .to.be.rejectedWith(Error, `No SCM token provided for GitLab.`);
  });

  it(`gets oauth credentials`, function () {
    this.conventionalGitlabReleaserMock.yields(null, []);

    const promise = this.plugin(this.config);

    return expect(promise).to.be.fulfilled
      .and.to.eventually.equal(true)
      .then(() => {
        expect(this.conventionalGitlabReleaserMock).to.have.been.calledOnce
          .and.calledWith({
            url: `https://gitlab.com`,
            token: this.config.options.scmToken,
          });
      });
  });

  it(`uses default preset`, function () {
    this.conventionalGitlabReleaserMock.yields(null, []);

    const promise = this.plugin(this.config);

    return expect(promise).to.be.fulfilled
      .and.to.eventually.equal(true)
      .then(() => {
        expect(this.conventionalGitlabReleaserMock).to.have.been.calledOnce
          .and.calledWith(
            {url: `https://gitlab.com`, token: this.config.options.scmToken},
            {preset: `angular`},
            {},
            {merges: null});
      });
  });

  it(`uses custom preset`, function () {
    this.conventionalGitlabReleaserMock.yields(null, []);
    this.config.options.preset = `crazy`;

    const promise = this.plugin(this.config);

    return expect(promise).to.be.fulfilled
      .and.to.eventually.equal(true)
      .then(() => {
        expect(this.conventionalGitlabReleaserMock).to.have.been.calledOnce
          .and.calledWith(
            {url: `https://gitlab.com`, token: this.config.options.scmToken},
            {preset: `crazy`},
            {},
            {merges: null});
      });
  });

  it(`uses http api protocol when set`, function () {
    this.conventionalGitlabReleaserMock.yields(null, []);
    this.config.options.insecureApi = true;

    const promise = this.plugin(this.config);

    return expect(promise).to.be.fulfilled
      .and.to.eventually.equal(true)
      .then(() => {
        expect(this.conventionalGitlabReleaserMock).to.have.been.calledOnce
          .and.calledWith(
            {url: `http://gitlab.com`, token: this.config.options.scmToken},
            {preset: `angular`},
            {},
            {merges: null});
      });
  });

  it(`returns true if conventional-gitlab-releaser succeeds`, function () {
    this.conventionalGitlabReleaserMock.yields(null, []);

    const promise = this.plugin(this.config);

    return expect(promise).to.be.fulfilled
      .and.to.eventually.equal(true);
  });

  it(`will reject if conventional-gitlab-releaser fails`, function () {
    this.conventionalGitlabReleaserMock.yields(new Error(`Failure.`), []);

    const promise = this.plugin(this.config);

    return expect(promise)
      .to.be.rejectedWith(Error, `Failure.`);
  });
});
