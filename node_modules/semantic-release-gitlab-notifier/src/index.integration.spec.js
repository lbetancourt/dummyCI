'use strict';

/* eslint-disable no-unused-expressions */

const chai = require(`chai`);
const chaiAsPromised = require(`chai-as-promised`);
const mocha = require(`mocha`);
const nock = require(`nock`);
const sinonChai = require(`sinon-chai`);

chai.use(chaiAsPromised);
chai.use(sinonChai);
const expect = chai.expect;

const before = mocha.before;
const beforeEach = mocha.beforeEach;
const describe = mocha.describe;
const it = mocha.it;

describe(`semantic-release-gitlab-notifier`, function () {
  before(function () {
    nock.disableNetConnect();
  });

  beforeEach(function () {
    this.config = {
      data: {
        commits: [
          `chore(package): initial setup\n\n`,
          `docs(README): add an introduction paragraph\n\nAdd introduction paragraph
            for the \`test-project\` project.\n\nCloses #1\n\n`,
          `docs(README): add 'as is' statement\n\n`,
          `Merge branch 'docs/readme/intro' into 'master'\r\n\r\nDocs/readme/intro
            \r\n\r\nCloses #1\r\n\r\nSee merge request !1\n`,
        ],
        version: `1.0.0`,
      },
      options: {
        debug: false,
        scmToken: `TOKEN`,
      },
      pkg: {
        repository: `https://gitlab.com/hyper-expanse/semantic-release-gitlab-notifier.git`,
      },
    };

    this.plugin = require(`./index`);
  });

  it(`does not run in debug mode`, function () {
    this.config.options.debug = true;

    const promise = this.plugin(this.config);

    return expect(promise).to.be.fulfilled
      .and.to.eventually.equal(false);
  });

  it(`will reject if a 'pkg' object is not passed in the 'config' argument`, function () {
    delete this.config.pkg;

    const promise = this.plugin(this.config);

    return expect(promise).to.be.rejectedWith(Error, 'This plugin, ' +
      '`semantic-release-gitlab-notifier`, was not passed the contents of your package\'s ' +
      '`package.json` file. Please contact the user of this plugin and request that they pass ' +
      'the contents of `package.json` to the plugin.');
  });

  it(`will reject if no repository information in 'pkg' property of 'config'`, function () {
    delete this.config.pkg.repository;

    const promise = this.plugin(this.config);

    return expect(promise)
      .to.be.rejectedWith(Error);
  });

  it(`will reject if no SCM token provided`, function () {
    delete this.config.options.scmToken;

    const promise = this.plugin(this.config);

    return expect(promise)
      .to.be.rejectedWith(Error, `No SCM token provided for GitLab.`);
  });

  it(`will reject if a version is not provided`, function () {
    delete this.config.data.version;

    const promise = this.plugin(this.config);

    return expect(promise)
      .to.be.rejectedWith(Error, `Invalid version provided to 'semantic-release-gitlab-notifier'.`);
  });

  it(`will reject if an invalid version is provided`, function () {
    this.config.data.version = `a.b.c`;

    const promise = this.plugin(this.config);

    return expect(promise)
      .to.be.rejectedWith(Error, `Invalid version provided to 'semantic-release-gitlab-notifier'.`);
  });

  it(`will reject if it fails to create a GitLab comment`, function () {
    const issueResponse = generateIssuesResponse();
    const notesResponse = generateNotesQuery()
      .reply(404);

    const promise = this.plugin(this.config);

    return promise
      .catch(function (error) {
        expect(error).to.an.instanceof(Error)
          .and.to.have.property(`message`, `Failed to post comment(s) to GitLab.`);

        issueResponse.done();
        notesResponse.done();
      });
  });

  it(`resolves with true on successful GitLab comment`, function () {
    const issueResponse = generateIssuesResponse();
    const notesResponse = generateNotesResponse();

    const promise = this.plugin(this.config);

    return promise
      .then(function (result) {
        expect(result).to.be.true;

        issueResponse.done();
        notesResponse.done();
      });
  });

  describe(`alternative respository URLs`, function () {
    it(`should succeed with SSH URL - git@gitlab.com`, function () {
      this.config.pkg.repository = `git@gitlab.com/hyper-expanse/semantic-release-gitlab-notifier.git`;

      const issueResponse = generateIssuesResponse();
      const notesResponse = generateNotesResponse();

      const promise = this.plugin(this.config);

      return promise
        .then(function (result) {
          expect(result).to.be.true;

          issueResponse.done();
          notesResponse.done();
        });
    });

    it(`should succeed with company deployed SSH URL - git@gitlab.company.com`, function () {
      this.config.pkg.repository = `git@gitlab.company.com/hyper-expanse/semantic-release-gitlab-notifier.git`;

      const issueResponse = generateIssuesResponse(`https://gitlab.company.com`);
      const notesResponse = generateNotesResponse(`https://gitlab.company.com`);

      const promise = this.plugin(this.config);

      return promise
        .then(function (result) {
          expect(result).to.be.true;

          issueResponse.done();
          notesResponse.done();
        });
    });

    it(`should succeed when using insecure HTTP protocol`, function () {
      this.config.options.insecureApi = true;

      const issueResponse = generateIssuesResponse(`http://gitlab.com`);
      const notesResponse = generateNotesResponse(`http://gitlab.com`);

      const promise = this.plugin(this.config);

      return promise
        .then(function (result) {
          expect(result).to.be.true;

          issueResponse.done();
          notesResponse.done();
        });
    });
  });
});

function generateIssuesResponse(customUrl) {
  const url = customUrl || `https://gitlab.com`;

  // jscs:disable
  return nock(`${url}`, {encodedQueryParams: true})
    .get(`/api/v3/projects/hyper-expanse%2Fsemantic-release-gitlab-notifier/issues`)
    .query({
      iid: `1`,
    })
    .reply(200, [{
      id: 2703002,
      iid: 1,
      project_id: 1483246,
      title: `Test Issue`,
      description: `Test issue`,
      state: `reopened`,
      created_at: `2016-08-05T01:45:51.696Z`,
      updated_at: `2016-08-08T01:05:23.246Z`,
      labels: [],
      milestone: null,
      assignee: null,
      author: {
        name: `Hutson Betts`,
        username: `hutson`,
        id: 484507,
        state: `active`,
        avatar_url: `https://secure.gravatar.com/avatar/eb31b926e665e155f94866789c698cef?s=80&d=identicon`,
        web_url: `${url}/u/hutson`,
      },
      subscribed: true,
      user_notes_count: 1,
      upvotes: 0,
      downvotes: 0,
      due_date: null,
    }]);
  // jscs:enable
}

function generateNotesQuery(customUrl) {
  const url = customUrl || `https://gitlab.com`;

  return nock(`${url}`, {encodedQueryParams: true})
    .post(
      `/api/v3/projects/hyper-expanse%2Fsemantic-release-gitlab-notifier/issues/2703002/notes`,
      `{"body":"Version [1.0.0](${url}/hyper-expanse/semantic-release-gitlab-notifier/tags/1.0.0) has been released."}`
    );
}

function generateNotesResponse(customUrl) {
  const url = customUrl || `https://gitlab.com`;

  // jscs:disable
  return generateNotesQuery(customUrl)
    .reply(201, {
      id: 13651519,
      body: `Version [1.0.0](${url}/hyper-expanse/semantic-release-gitlab-notifier/tags/1.0.0) has been released.`,
      attachment: null,
      author: {
        name: `Hutson Betts`,
        username: `hutson`,
        id: 484507,
        state: `active`,
        avatar_url: `https://secure.gravatar.com/avatar/eb31b926e665e155f94866789c698cef?s=80&d=identicon`,
        web_url: `${url}/u/hutson`,
      },
      created_at: `2016-08-08T01:05:44.468Z`,
      updated_at: `2016-08-08T01:05:44.468Z`,
      system: false,
      noteable_id: 2703002,
      noteable_type: `Issue`,
      'upvote?': false,
      'downvote?': false,
    });
  // jscs:enable
}
